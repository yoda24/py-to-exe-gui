# Form implementation generated from reading ui file 'design.ui'
#
# Created by: PyQt6 UI code generator 6.9.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

import sys, os, subprocess, threading, glob, shutil, psutil
from PyQt6 import QtCore, QtGui, QtWidgets, QtNetwork 

class LogSignal(QtCore.QObject):
    message = QtCore.pyqtSignal(str)
    
class Ui_py2exe(object):
    def setupUi(self, py2exe):
        self.log_signal = LogSignal()
        self.log_signal.message.connect(self.append_log)
        self.fpid = None
        self.pid_path = os.path.join(os.path.dirname(sys.argv[0]), "pyinstaller.pid")
        self.log_file = os.path.join(os.path.dirname(sys.argv[0]), "pyinstaller.log")
        
        py2exe.setObjectName("py2exe")
        py2exe.resize(380, 424)
        py2exe.setMinimumSize(QtCore.QSize(380, 375))
        py2exe.setMaximumSize(QtCore.QSize(380, 16777215))
        self.centralwidget = QtWidgets.QWidget(parent=py2exe)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setContentsMargins(9, -1, -1, 0)
        self.gridLayout.setObjectName("gridLayout")
        self.gb_opts = QtWidgets.QGroupBox(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.gb_opts.sizePolicy().hasHeightForWidth())
        self.gb_opts.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setBold(False)
        font.setItalic(False)
        self.gb_opts.setFont(font)
        self.gb_opts.setMouseTracking(False)
        self.gb_opts.setObjectName("gb_opts")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.gb_opts)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.ck_clear_cache = QtWidgets.QCheckBox(parent=self.gb_opts)
        self.ck_clear_cache.setChecked(True)
        self.ck_clear_cache.setObjectName("ck_clear_cache")
        self.gridLayout_2.addWidget(self.ck_clear_cache, 0, 1, 1, 1)
        self.ck_log_level = QtWidgets.QCheckBox(parent=self.gb_opts)
        self.ck_log_level.setObjectName("ck_log_level")
        self.gridLayout_2.addWidget(self.ck_log_level, 2, 0, 1, 1)
        self.ck_one_file = QtWidgets.QCheckBox(parent=self.gb_opts)
        self.ck_one_file.setChecked(True)
        self.ck_one_file.setObjectName("ck_one_file")
        self.gridLayout_2.addWidget(self.ck_one_file, 0, 0, 1, 1)
        self.ck_windowed = QtWidgets.QCheckBox(parent=self.gb_opts)
        self.ck_windowed.setObjectName("ck_windowed")
        self.gridLayout_2.addWidget(self.ck_windowed, 1, 0, 1, 1)
        self.ck_save_to_log_file = QtWidgets.QCheckBox(parent=self.gb_opts)
        self.ck_save_to_log_file.setChecked(True)
        self.ck_save_to_log_file.setObjectName("ck_save_to_log_file")
        self.gridLayout_2.addWidget(self.ck_save_to_log_file, 2, 1, 1, 1)
        self.ck_remove_spec_file = QtWidgets.QCheckBox(parent=self.gb_opts)
        self.ck_remove_spec_file.setObjectName("ck_remove_spec_file")
        self.gridLayout_2.addWidget(self.ck_remove_spec_file, 1, 1, 1, 1)
        self.gridLayout.addWidget(self.gb_opts, 2, 0, 1, 1)
        self.log_output = QtWidgets.QPlainTextEdit(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(1)
        sizePolicy.setHeightForWidth(self.log_output.sizePolicy().hasHeightForWidth())
        self.log_output.setSizePolicy(sizePolicy)
        self.log_output.setReadOnly(True)
        self.log_output.setObjectName("log_output")
        self.gridLayout.addWidget(self.log_output, 3, 0, 1, 1)
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame.sizePolicy().hasHeightForWidth())
        self.frame.setSizePolicy(sizePolicy)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_3.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_3.setSpacing(4)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.btn_main_browse = QtWidgets.QPushButton(parent=self.frame)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Maximum, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.btn_main_browse.sizePolicy().hasHeightForWidth())
        self.btn_main_browse.setSizePolicy(sizePolicy)
        self.btn_main_browse.setObjectName("btn_main_browse")
        self.btn_main_browse.clicked.connect(self.browse_py_file)
        self.gridLayout_3.addWidget(self.btn_main_browse, 0, 1, 1, 1)
        self.le_main_path = QtWidgets.QLineEdit(parent=self.frame)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.le_main_path.sizePolicy().hasHeightForWidth())
        self.le_main_path.setSizePolicy(sizePolicy)
        self.le_main_path.setMinimumSize(QtCore.QSize(0, 0))
        self.le_main_path.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.le_main_path.setReadOnly(True)
        self.le_main_path.setObjectName("le_main_path")
        self.gridLayout_3.addWidget(self.le_main_path, 0, 0, 1, 1)
        self.le_icon_path = QtWidgets.QLineEdit(parent=self.frame)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.le_icon_path.sizePolicy().hasHeightForWidth())
        self.le_icon_path.setSizePolicy(sizePolicy)
        self.le_icon_path.setReadOnly(True)
        self.le_icon_path.setObjectName("le_icon_path")
        self.gridLayout_3.addWidget(self.le_icon_path, 1, 0, 1, 1)
        self.btn_ico_browse = QtWidgets.QPushButton(parent=self.frame)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Maximum, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.btn_ico_browse.sizePolicy().hasHeightForWidth())
        self.btn_ico_browse.setSizePolicy(sizePolicy)
        self.btn_ico_browse.setObjectName("btn_ico_browse")
        self.btn_ico_browse.clicked.connect(self.browse_icon_file)
        self.gridLayout_3.addWidget(self.btn_ico_browse, 1, 1, 1, 1)
        self.gridLayout.addWidget(self.frame, 0, 0, 1, 1)
        self.btn_start_conversion = QtWidgets.QPushButton(parent=self.centralwidget)
        self.btn_start_conversion.setObjectName("btn_start_conversion")
        self.btn_start_conversion.clicked.connect(self.start_conversion)
        self.gridLayout.addWidget(self.btn_start_conversion, 1, 0, 1, 1)
        py2exe.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(parent=py2exe)
        self.statusbar.setObjectName("statusbar")
        py2exe.setStatusBar(self.statusbar)

        py2exe.closeEvent = self.on_close
        self.cleanup_stale_pyinstaller()
        
        self.retranslateUi(py2exe)
        QtCore.QMetaObject.connectSlotsByName(py2exe)

    #on close event
    def on_close(self, event):
        reply = QtWidgets.QMessageBox.question(
            None, "Confirm Exit", "Are you sure you want to exit?",
                QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No
            )
        if reply == QtWidgets.QMessageBox.StandardButton.Yes:
            self.kill_own_pyinstaller()
            event.accept()
        else: event.ignore()

    # --- UI: browse ---
    def browse_py_file(self):
        file, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Select file .py", "", "Python Files (*.py)")
        if file: self.le_main_path.setText(file)

    def browse_icon_file(self):
        file, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Select file icon", "", "Icon Files (*.ico)")
        if file: self.le_icon_path.setText(file)
            
    # --- Append log safely ---
    def append_log(self, text):
        self.log_output.appendPlainText(text)
        self.log_output.moveCursor(QtGui.QTextCursor.MoveOperation.End)
    def append_log_file(self, *messages, show = False):
        with open(self.log_file, "a", encoding="utf-8", buffering=1) as logf:
            for msg in messages:
                # --- process.stdout
                if hasattr(msg, "readline"):
                    for line in msg:
                        line = line.rstrip()
                        if self.ck_save_to_log_file.isChecked(): logf.write(line + "\n")
                        if show: self.log_signal.message.emit(line) 
                # --- list/tuple
                elif isinstance(msg, (list, tuple)):
                    for item in msg:
                        line = str(item)
                        if self.ck_save_to_log_file.isChecked(): logf.write(line + "\n")
                        if show: self.log_signal.message.emit(line) 
                # --- string
                else:
                    line = str(msg)
                    if self.ck_save_to_log_file.isChecked(): logf.write(line + "\n")
                    if show: self.log_signal.message.emit(line) 

    # --- Start The Conversion ---
    def start_conversion(self):
        py_file = self.le_main_path.text().strip()
        if not py_file.endswith(".py") or not os.path.isfile(py_file):
            QtWidgets.QMessageBox.warning(None, "Error", "File is not .py or not found")
            return

        self.log_output.clear()
        thread = threading.Thread(target=self.convert_py_to_exe, args=(py_file,), daemon=True)
        thread.start()

    # --- Check if PyInstaller running --- 
    def is_pyinstaller_running(self):
        current_pid = os.getpid()
        for proc in psutil.process_iter(['pid', 'ppid', 'cmdline']):
            try:
                if proc.info['ppid'] != current_pid: continue
                cmdline = proc.info.get('cmdline', [])
                if not cmdline: continue
                if any("pyinstaller" in arg.lower() for arg in cmdline): return True
            except (psutil.NoSuchProcess, psutil.AccessDenied): continue
        return False

    # --- Cleanup PyInstaller --- 
    def cleanup_stale_pyinstaller(self):
        try:
            if os.path.exists(self.pid_path):
                with open(self.pid_path) as f: old_pid = int(f.read().strip())
                if psutil.pid_exists(old_pid):
                    proc = psutil.Process(old_pid)
                    if "pyinstaller" in " ".join(proc.cmdline()).lower():
                        proc.kill()
                        self.append_log_file(f"Killed previous PyInstaller (PID={old_pid})", show=True)
        except Exception as e:
            self.append_log_file(f"Cleanup failed: {e}", show=True)
        finally:
            if os.path.exists(self.pid_path): os.remove(self.pid_path)

    # --- Kill pyinstaller --- #
    def kill_own_pyinstaller(self):
        current_pid = os.getpid()
        killed = False

        for proc in psutil.process_iter(['pid', 'ppid', 'name', 'cmdline']):
            try:
                cmdline = proc.info.get('cmdline', [])
                if not cmdline: continue
                if "pyinstaller" in " ".join(cmdline).lower() and proc.info['ppid'] == current_pid:
                    self.append_log_file(f"* Terminating leftover PyInstaller (PID={proc.info['pid']}) *", show=True)

                    # Coba terminate dulu, tunggu sebentar
                    proc.terminate()
                    try:
                        proc.wait(timeout=3)
                    except psutil.TimeoutExpired:
                        proc.kill()
                        proc.wait()

                    killed = True
                    self.append_log_file(f"* PyInstaller process PID={proc.info['pid']} stopped *", show=True)

                    # Tutup dan hapus .pid jika ada
                    if os.path.exists(self.pid_path) and self.fpid:
                        try:
                            if not self.fpid.closed: self.fpid.close()
                            os.remove(self.pid_path)
                        except Exception as e:
                            self.append_log_file(f"Failed to remove .pid: {e}", show=True)

            except (psutil.NoSuchProcess, psutil.AccessDenied): continue

        if not killed:
            self.append_log_file("* No previous PyInstaller process found to kill *", show=True)



    # --- Core Conversion ---
    def convert_py_to_exe(self, py_file):
        base_name = os.path.splitext(os.path.basename(py_file))[0]
        parent_dir = os.path.dirname(py_file)
        output_dir = os.path.join(parent_dir, base_name + "_exe")
        os.makedirs(output_dir, exist_ok=True)

        if self.is_pyinstaller_running():
            self.append_log_file("PyInstaller is still running. Please wait or close it first.", show=True)
            self.kill_own_pyinstaller()
            return

        # --- Cleanup old files ---
        try:
            spec_file = f"{base_name}.spec"
            if self.ck_remove_spec_file.isChecked() and os.path.exists(spec_file):
                os.remove(spec_file)
                self.append_log_file(f"Deleted spec file: {spec_file}", show=True)

        except Exception as e:
            self.append_log_file(f"Failed to delete: {e}", show=True)
            return

        # --- Run PyInstaller ---
        try:
            icon_file = self.le_icon_path.text().strip()
            cmd = [
                sys.executable, "-u", "-m", "PyInstaller", "--noconfirm", "--distpath", output_dir
            ] 
            if self.ck_one_file.isChecked(): cmd.insert(4, "--onefile") 
            if self.ck_clear_cache.isChecked(): cmd.insert(5, "--clean") 
            if self.ck_log_level.isChecked(): cmd.insert(6, "--log-level=DEBUG")
            if self.ck_windowed.isChecked(): cmd.insert(7, "--windowed")
                        
            if icon_file and os.path.isfile(icon_file):
                abs_icon = os.path.abspath(icon_file)
                cmd.append(f"--icon={abs_icon}")
                if os.name == "nt": cmd.append(f"--add-data={abs_icon};.")
                else: cmd.append(f"--add-data={abs_icon}:.")

            cmd.append(py_file)
            self.log_signal.message.emit(f"Running: {' '.join(cmd)}")

            try:
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    bufsize=1,
                    creationflags=subprocess.CREATE_NO_WINDOW if os.name == "nt" else 0
                )

                self.fpid = open(self.pid_path, "w")
                self.fpid.write(str(process.pid))
                self.fpid.flush()
                if os.name == "nt": subprocess.call(["attrib", "+H", self.pid_path])

                self.append_log_file(process.stdout, show=True)

                process.wait()
                
                #whatever result from pyinstaller keep remove .pid
                if os.path.exists(self.pid_path) and self.fpid:
                    try:
                        if not self.fpid.closed: self.fpid.close()
                        os.remove(self.pid_path)
                    except: pass

            except Exception as e:
                self.append_log_file(f"Exception during PyInstaller run: {e}", show=True)
                
            self.log_signal.message.emit(f"\nFull log saved to: {self.log_file}")
            
            if process.returncode == 0:
                self.append_log_file(f"Success! EXE saved to:\n{output_dir}", show=True)
                try:
                    if os.path.exists(self.pid_path): os.remove(self.pid_path)
                except: pass
            else: self.append_log_file(f"PyInstaller failed with code: {process.returncode}", show=True)

        except Exception as e:
            self.append_log_file(f"Exception: {e}", show=True)
            return

     
    def retranslateUi(self, py2exe):
        _translate = QtCore.QCoreApplication.translate
        py2exe.setWindowTitle(_translate("py2exe", "Py to Exe - Quick Converter [pyinstaller]"))
        self.gb_opts.setTitle(_translate("py2exe", "Quick Options"))
        self.ck_clear_cache.setText(_translate("py2exe", "Clear Cache"))
        self.ck_log_level.setText(_translate("py2exe", "log-level=DEBUG"))
        self.ck_one_file.setText(_translate("py2exe", "One File (.exe only)"))
        self.ck_windowed.setText(_translate("py2exe", "Windowed"))
        self.ck_save_to_log_file.setText(_translate("py2exe", "Save to log file"))
        self.ck_remove_spec_file.setText(_translate("py2exe", "Remove .spec file"))
        self.btn_main_browse.setText(_translate("py2exe", "Choose  .py"))
        self.le_main_path.setPlaceholderText(_translate("py2exe", "main.py"))
        self.le_icon_path.setPlaceholderText(_translate("py2exe", ".ico file"))
        self.btn_ico_browse.setText(_translate("py2exe", "Choose .ico"))
        self.btn_start_conversion.setText(_translate("py2exe", "Start"))


def is_another_instance_running(server_name="py2exe_single_instance"):
    socket = QtNetwork.QLocalSocket()
    socket.connectToServer(server_name)
    if socket.waitForConnected(100): return True
    return False

def create_single_instance_server(server_name="py2exe_single_instance", on_message=None):
    QtNetwork.QLocalServer.removeServer(server_name)
    server = QtNetwork.QLocalServer()
    server.listen(server_name)
    if on_message: server.newConnection.connect(on_message)
    return server


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)

    server_name = "py2exe_single_instance"
    if is_another_instance_running(server_name):
        QtWidgets.QMessageBox.warning(None, ".", "The app is already running.")
        sys.exit(0)
    server = create_single_instance_server(server_name)

    py2exe = QtWidgets.QMainWindow()
    ui = Ui_py2exe()
    ui.setupUi(py2exe)
    py2exe.show()
    sys.exit(app.exec())
